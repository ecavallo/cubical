{-# OPTIONS --cubical #-}
module Cubical.Experiments.Equivariant where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Transport
import Cubical.Data.Empty as ⊥
open import Cubical.Data.Fin hiding (elim)
open import Cubical.Data.Nat hiding (elim)
open import Cubical.Data.Nat.Order

[] : Fin 0 → I
[] (k , less) with ¬-<-zero less
[] (k , less) | ()

infixr 20 _∷_

_∷_ : ∀ {n} → I → (Fin n → I) → (Fin (suc n) → I)
(i ∷ f) (zero , less) = i
(i ∷ f) (suc k , less) = f (k , <-k+-cancel less)

cnx∧ : ∀ {n} → (Fin n → I) → I → (Fin n → I)
cnx∧ i k f = i f ∧ k

{-
  n-ary equivariant composition from CCHM/OP-style composition for Dedekind cubes.
  (Some reversals occur in this definition, but only to simulate composition 1→0
-}

module _ (n : ℕ) where

  module Fill {ℓ} (A : (Fin n → I) → Type ℓ) {φ : I}
    (u : ∀ i → Partial φ (A i))
    (i : Fin n → I)
    (a : A i [ φ ↦ u i ])
    where

    ⇒ : ∀ j → A j [ φ ↦ u j ]
    ⇒ j = inS
      (comp
        (λ k → A (cnx∧ j k))
        (λ k → λ {(φ = i1) → u (cnx∧ j k) 1=1})
        (comp
          (λ k → A (cnx∧ i (~ k)))
          (λ k → λ {(φ = i1) → u (cnx∧ i (~ k)) 1=1})
          (outS a)))

    cap : (outS (⇒ i) ≡ outS a) [ φ ↦ (λ {(φ = i1) → refl}) ]
    cap = inS
      (λ l →
        comp
          (λ k → A (cnx∧ i (k ∨ l)))
          (λ k → λ
            { (φ = i1) → u (cnx∧ i (k ∨ l)) 1=1
            ; (l = i1) → outS a
            })
          (comp
            (λ k → A (cnx∧ i (~ k ∨ l)))
            (λ k → λ
              { (φ = i1) → u (cnx∧ i (~ k ∨ l)) 1=1
              ; (l = i1) → outS a
              })
            (outS a)))

  module Coe {ℓ} (A : (Fin n → I) → Type ℓ) (i : Fin n → I) (a : A i)
    where

    module F = Fill A {φ = i0} (λ _ → λ ()) i (inS a)

    ⇒ : ∀ j → A j
    ⇒ j = outS (F.⇒ j)

    cap : (⇒ i) ≡ a
    cap = outS F.cap

{-
  Simulating connections using equivariant composition

  Past this point, we don't use connections except via Fill/Coe defined above,
  so the terms below can be defined in equivariant cartesian cubical type theory.
-}


{-

  The key lemma is n-dimensional singleton contractibility; this is also the
  only place where equivariance is used. As with transp in CHM, we define the
  lemma relative to a cofibration φ on which the input is assumed to be constant
  and guarantee the output is constant on the same φ, which will be convenient
  later on.

-}

singl1 : {A : Type₀} (a : A) (φ : I) (p : I → A [ φ ↦ (λ _ → a) ])
  (k : I) → I → A [ φ ∨ ~ k ↦ (λ _ → outS (p i0)) ]
singl1 {A = A} a φ p k l =
  inS
    (outS
      (Fill.⇒ 1
        (λ _ → A)
        (λ m → λ
          { (k = i0) → outS (p i0)
          ; (k = i1) → outS (p l)
          ; (l = i0) → outS (Face.cap k) (m fzero)
          ; (φ = i1) → a
          })
        (λ _ → i0)
        (inS (outS (Face.⇒ k (λ _ → l))))
        (λ _ → i1)))
  where
  module Face (k : I) =
    Fill 1
      (λ _ → A)
      (λ l → λ
        { (k = i0) → outS (p i0)
        ; (k = i1) → outS (p (l fzero))
        ; (φ = i1) → a
        })
      (λ _ → i0)
      (inS (outS (p i0)))

singl2 : {A : Type₀} (a : A) (φ : I) (α : I → I → A [ φ ↦ (λ _ → a) ])
  (k : I) → I → I → A [ φ ∨ ~ k ↦ (λ _ → outS (α i0 i0)) ]
singl2 {A = A} a φ α k l₀ l₁ =
  inS
    (outS
      (Fill.⇒ 1
        (λ _ → A)
        (λ m → λ
          { (k = i0) → outS (α i0 i0)
          ; (k = i1) → outS (α l₀ l₁)
          ; (l₀ = i0) (l₁ = i0) → outS (Face.cap k) (m fzero)
          ; (φ = i1) → a
          })
        (λ _ → i0)
        (inS (outS (Face.⇒ k (l₀ ∷ l₁ ∷ []))))
        (λ _ → i1)))
  where
  module Face (k : I) =
    Fill 2
      (λ _ → A)
      (λ l → λ
        { (k = i0) → outS (α i0 i0)
        ; (k = i1) → outS (α (l fzero) (l (fsuc fzero)))
        ; (φ = i1) → a
        })
      (λ _ → i0)
      (inS (outS (α i0 i0)))

{-
  Examples of connections

  We're interested in defining "α ∘ f" : Iᵐ → A where α : Iⁿ → A is some n-cube
  and f : Iᵐ → Iⁿ is a map generated by connections. We need this definition to
  be well-defined in the sense of respecting equations like x ∧ y = y ∧ x, but
  also to commute with cartesian substitutions.

  We do this using singleton contractibility to reduce to the case where α is
  constant, so more-or-less "by J". (Using the cofibration φ, we csidestep the
  issue of J not being definitionally identity on refl.)

  The definitions below show how to define "α ∘ f" for a small instances of f;
  hopefully the general pattern is clear. In order to ensure the definition
  commutes with degeneracies, we should first factor f maximally as some f' ⊗ Iᵏ
  and then apply the reciple to f'.

  Since Cubical Agda does not have diagonal cofibrations, we cannot ensure our
  definitions commute with diagonal substitutions; but if we did have them, we
  could do it in the same was we ensure they commute with faces.
-}

-- f(i₀,i₁) = i₀ ∧ i₁
and : {A : Type₀} (a : A) (φ : I)
  → (I → A [ φ ↦ (λ _ → a) ]) → I → I → A
and {A = A} _ φ p i₀ i₁ =
  hcomp
    (λ l → λ
      { (i₀ = i0) → a
      ; (i₀ = i1) → outS (singl1 a φ p l i₁)
      ; (i₁ = i0) → a
      ; (i₁ = i1) → outS (singl1 a φ p l i₀)
      ; (φ = i1) → a
      })
    a
  where
  a = outS (p i0)

-- f(i₀,i₁) = i₀ ∨ i₁
or : {A : Type₀} (a : A) (φ : I)
  → (I → A [ φ ↦ (λ _ → a) ]) → I → I → A
or {A = A} _ φ p i₀ i₁ =
  hcomp
    (λ l → λ
      { (i₀ = i0) → outS (singl1 a φ p l i₁)
      ; (i₀ = i1) → outS (singl1 a φ p l i1)
      ; (i₁ = i0) → outS (singl1 a φ p l i₀)
      ; (i₁ = i1) → outS (singl1 a φ p l i1)
      ; (φ = i1) → a
      })
    a
  where
  a = outS (p i0)

-- f(i₀,i₁,i₂) = i₀ ∧ i₁ ∧ i₂
ternaryAnd : {A : Type₀} (a : A) (φ : I)
  → (I → A [ φ ↦ (λ _ → a) ]) → I → I → I → A
ternaryAnd {A = A} _ φ p i₀ i₁ i₂ =
  hcomp
    (λ l → λ
      { (i₀ = i0) → a
      ; (i₀ = i1) → and a (φ' l) (α' l) i₁ i₂
      ; (i₁ = i0) → a
      ; (i₁ = i1) → and a (φ' l) (α' l) i₀ i₂
      ; (i₂ = i0) → a
      ; (i₂ = i1) → and a (φ' l) (α' l) i₀ i₁
      ; (φ = i1) → a
      })
    a
  where
  a = outS (p i0)

  φ' : I → I
  φ' l = φ ∨ ~ l

  α' : (l : I) → I → A [ φ ∨ ~ l ↦ (λ _ → a) ]
  α' = singl1 a φ p

-- f(i₀,i₁,j₀,j₁) = (i₀ ∧ i₁, j₀ ∧ j₁)
doubleAnd : {A : Type₀} (a : A) (φ : I)
  → (I → I → A [ φ ↦ (λ _ → a) ]) → I → I → I → I → A
doubleAnd {A = A} _ φ α i₀ i₁ j₀ j₁ =
  hcomp
    (λ l → λ
      { (i₀ = i0) → and a (φ' l) (λ j → α' l i0 j) j₀ j₁
      ; (i₀ = i1) → and a (φ' l) (λ j → α' l i₁ j) j₀ j₁
      ; (i₁ = i0) → and a (φ' l) (λ j → α' l i0 j) j₀ j₁
      ; (i₁ = i1) → and a (φ' l) (λ j → α' l i₀ j) j₀ j₁
      ; (j₀ = i0) → and a (φ' l) (λ i → α' l i i0) i₀ i₁
      ; (j₀ = i1) → and a (φ' l) (λ i → α' l i j₁) i₀ i₁
      ; (j₁ = i0) → and a (φ' l) (λ i → α' l i i0) i₀ i₁
      ; (j₁ = i1) → and a (φ' l) (λ i → α' l i j₀) i₀ i₁
      ; (φ = i1) → outS (α i0 i0)
      })
    (outS (α i0 i0))
  where
  a : A
  a = outS (α i0 i0)

  φ' : I → I
  φ' l = φ ∨ ~ l

  α' : (l : I) → I → I → A [ φ ∨ ~ l ↦ (λ _ → outS (α i0 i0)) ]
  α' = singl2 a φ α

private
  -- This is the equation that relies on equivariance
  test₀ : {A : Type₀} (α : I → I → A)
    → ∀ i₀ i₁ j₀ j₁
    → doubleAnd (α i0 i0) i0 (λ i j → inS (α i j)) i₀ i₁ j₀ j₁
      ≡ doubleAnd (α i0 i0) i0 (λ j i → inS (α i j)) j₀ j₁ i₀ i₁
  test₀ α i₀ i₁ j₀ j₁ = refl

-- f(i₀,i₁,j₀,j₁) = (i₀ ∨ i₁, j₀ ∨ j₁)
doubleOr : {A : Type₀} (a : A) (φ : I)
  → (I → I → A [ φ ↦ (λ _ → a) ]) → I → I → I → I → A
doubleOr {A = A} _ φ α i₀ i₁ j₀ j₁ =
  hcomp
    (λ l → λ
      { (i₀ = i0) → or a (φ' l) (λ j → α' l i₁ j) j₀ j₁
      ; (i₀ = i1) → or a (φ' l) (λ j → α' l i1 j) j₀ j₁
      ; (i₁ = i0) → or a (φ' l) (λ j → α' l i₀ j) j₀ j₁
      ; (i₁ = i1) → or a (φ' l) (λ j → α' l i1 j) j₀ j₁
      ; (j₀ = i0) → or a (φ' l) (λ i → α' l i j₁) i₀ i₁
      ; (j₀ = i1) → or a (φ' l) (λ i → α' l i i1) i₀ i₁
      ; (j₁ = i0) → or a (φ' l) (λ i → α' l i j₀) i₀ i₁
      ; (j₁ = i1) → or a (φ' l) (λ i → α' l i i1) i₀ i₁
      ; (φ = i1) → outS (α i0 i0)
      })
    (outS (α i0 i0))
  where
  a : A
  a = outS (α i0 i0)

  φ' : I → I
  φ' l = φ ∨ ~ l

  α' : (l : I) → I → I → A [ φ ∨ ~ l ↦ (λ _ → outS (α i0 i0)) ]
  α' = singl2 a φ α
